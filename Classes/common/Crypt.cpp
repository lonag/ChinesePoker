#include "../common/Crypt.h"
#include "../common/des.h"
static UCHAR des_keys_A[20][3][8] = 
{
	23,90,37,87,165,16,2,7,
	24,114,151,238,148,164,166,173,
	25,139,35,18,166,75,241,159,
	47,186,221,239,150,225,211,115,
	49,235,201,185,80,50,6,121,
	72,52,253,183,8,58,64,185,
	96,148,146,74,82,140,204,134,
	121,14,160,234,61,201,150,29,
	168,182,87,66,127,73,223,252,
	217,144,231,42,169,242,210,207,
	34,178,154,196,110,97,52,4,
	130,53,207,148,3,100,152,156,
	251,49,1,149,152,252,149,50,
	164,213,214,108,5,2,151,201,
	126,84,43,151,156,158,54,255,
	160,244,32,183,84,242,41,41,
	35,24,56,239,68,55,96,137,
	31,55,111,95,163,218,59,196,
	195,250,106,201,109,72,131,72,
	66,61,167,113,222,39,170,242,
	226,32,199,57,24,63,233,220,
	6,38,237,39,63,126,104,69,
	37,75,57,96,159,30,134,203,
	232,52,109,205,109,139,18,221,
	43,95,204,154,8,147,165,131,
	14,109,58,212,220,112,22,153,
	20,129,187,144,109,221,243,141,
	57,186,118,7,116,82,70,211,
	34,220,83,90,206,33,103,59,
	77,42,125,215,166,199,47,106,
	91,133,3,218,129,73,120,226,
	111,244,247,210,84,157,22,248,
	168,157,149,104,188,90,112,105,
	202,104,253,102,35,125,237,87,
	24,128,126,228,8,133,115,202,
	115,243,114,87,95,228,88,35,
	226,214,73,160,255,228,61,96,
	139,98,171,76,76,49,110,206,
	86,184,100,176,252,46,156,107,
	110,39,139,60,57,103,4,111,
	225,9,148,208,10,113,117,228,
	196,205,98,51,61,174,36,9,
	80,30,128,179,240,159,195,204,
	166,196,69,248,233,137,77,26,
	21,217,31,24,2,139,216,242,
	246,208,239,8,10,149,110,97,
	187,140,124,132,142,36,146,243,
	12,152,21,153,40,76,222,210,
	178,75,96,249,34,110,77,32,
	199,19,115,109,143,253,75,107,
	190,209,69,178,66,64,139,246,
	122,76,145,68,134,198,82,73,
	134,210,100,168,47,245,72,145,
	57,12,112,25,72,62,134,24,
	1,13,125,150,222,29,163,187,
	191,204,74,224,191,220,128,60,
	58,7,81,50,241,206,79,139,
	192,199,25,75,61,12,91,230,
	249,193,218,38,99,111,202,177,
	250,188,151,189,33,144,91,13
};

static UCHAR des_keys_B[20][3][8] = 
{
	23,201,185,80,50,6,121,72,52,253,
	183,7,204,74,224,191,220,128,60,58,
	7,81,50,241,206,79,139,192,199,25,
	75,61,12,91,230,121,14,160,234,61,
	201,150,29,168,182,87,66,127,73,223,
	249,193,24,114,151,238,148,164,166,173,
	225,211,115,49,235,185,96,148,146,74,
	82,140,204,134,252,152,156,251,49,1,
	149,152,252,149,50,164,217,144,231,42,
	169,242,210,207,34,178,154,196,110,97,
	52,4,130,53,207,148,3,100,213,214,
	108,5,2,151,201,126,84,43,151,156,
	158,54,255,160,244,32,183,84,242,41,
	41,35,24,56,239,68,55,96,137,31,
	55,111,95,163,218,59,196,195,250,106,
	201,109,72,131,72,66,61,167,113,222,
	39,170,242,226,32,199,57,24,63,233,
	220,6,38,237,39,63,126,104,69,37,
	75,57,96,159,30,134,203,232,52,109,
	205,109,139,18,221,43,95,204,154,8,
	147,165,131,14,109,58,212,220,112,22,
	153,20,129,187,144,109,221,243,141,57,
	186,118,7,116,82,70,211,34,220,83,
	90,206,33,103,59,77,42,125,215,166,
	199,47,106,91,133,3,218,129,73,120,
	226,111,244,247,210,84,157,22,248,168,
	157,149,104,188,90,112,105,202,104,253,
	102,35,125,237,87,24,128,126,228,8,
	133,115,202,115,243,114,87,95,228,88,
	35,226,214,73,160,255,228,61,96,139,
	98,171,76,76,49,110,206,86,184,100,
	176,252,46,156,107,110,39,139,60,57,
	103,4,111,225,9,148,208,10,113,117,
	228,196,205,98,51,61,174,36,9,80,
	30,128,179,240,159,195,204,166,196,69,
	248,233,137,77,26,21,217,31,24,2,
	139,216,242,246,208,239,8,10,149,110,
	97,187,140,124,132,142,36,146,243,12,
	152,21,153,40,76,222,210,178,75,96,
	249,34,110,77,32,199,19,115,109,143,
	253,75,107,190,209,69,178,66,64,139,
	246,122,76,145,68,134,198,82,73,134,
	210,100,168,47,245,72,145,57,12,112,
	25,72,62,134,24,1,13,125,150,222,
	29,163,187,191,218,8,58,64,90,37,
	87,165,16,2,38,99,111,202,177,250,
	188,151,189,33,144,91,13,25,139,35,
	18,166,75,241,159,47,186,221,239,150
};
bool Crypt::crypt(UCHAR* pIn, UCHAR* pOut, const int nLen, UCHAR* key, bool bEncypt/* =0 */)
{
	// 检测输入和输出是否是8字节的整数倍
	if( nLen % 8 != 0 || nLen <= 0 )
		return false;

	// 设置密钥
	des3_context ctx3;
	des3_set_3keys(&ctx3, key, key+8, key+16);

	// 依次读取输入buff里面的8个字节，并进行加解密
	for(int i = 0; i < nLen; i += 8)
	{
		if( bEncypt )
			des3_encrypt(&ctx3, &pIn[i], &pOut[i]);
		else
			des3_decrypt(&ctx3, &pIn[i], &pOut[i]);
	}

	return true;
}
//---------------------------------------------------------------------------------------
// 对某段内存区域进行加密
//---------------------------------------------------------------------------------------
bool Crypt::Encrypt(void* pIn, void* pOut, const int nLen, UCHAR* key)
{
	return crypt((UCHAR*)pIn, (UCHAR*)pOut, nLen, key, 1);
}

//---------------------------------------------------------------------------------------
// 对某段内存区域进行解密
//---------------------------------------------------------------------------------------
bool Crypt::Decrypt(void* pIn, void* pOut, const int nLen, UCHAR* key)
{
	return crypt((UCHAR*)pIn, (UCHAR*)pOut, nLen, key, 0);
}

UCHAR* GetKeys(const int nIndex, const int nMethod)
{
	switch(nMethod)
	{
	case 0:
		return (UCHAR*)des_keys_A[nIndex];
	case 1:
		return (UCHAR*)des_keys_B[nIndex];
	default:
		//ASSERT(0);
		return NULL;
	}	
}
//-----------------------------------------------------------------------------------------
// 对某段内存区域进行加密，使用静态密钥索引
//-----------------------------------------------------------------------------------------
bool Crypt::Encrypt(void* pIn, void *pOut, const int nLen, const int nIndex, const int nMethod)
{
	//ASSERT( nIndex >= 0 && nIndex < 20 );
	//ASSERT( nMethod >= 0 && nMethod < 2);
	UCHAR* pKeys = GetKeys(nIndex, nMethod);
// 	if(!P_VALID(pKeys))
// 		return FALSE;
	return crypt((UCHAR*)pIn, (UCHAR*)pOut, nLen, pKeys, 1);
}

//-----------------------------------------------------------------------------------------
// 对某段内存区域进行解密，使用静态密钥索引
//-----------------------------------------------------------------------------------------
bool Crypt::Decrypt(void* pIn, void *pOut, const int nLen, const int nIndex, const int nMethod)
{
	//ASSERT( nIndex >= 0 && nIndex < 20 );
	//ASSERT( nMethod >= 0 && nMethod < 2);
	UCHAR* pKeys = GetKeys(nIndex, nMethod);
// 	if(!P_VALID(pKeys))
// 		return FALSE;
	return crypt((UCHAR*)pIn, (UCHAR*)pOut, nLen, pKeys, 0);
}

